# 飞书应用安全加固技术方案

## 📋 文档说明

本文档详细介绍了飞书应用数据安全加固的完整技术方案，包括：
- **Docker 数据持久化**：确保数据不因容器重建而丢失
- **数据库字段加密**：保护敏感数据不被直接读取
- **环境变量加密**：保护配置中的敏感信息

**目标读者**：初学者到中级开发者  
**文档目的**：理解方案原理、实现方式和安全价值

---

## 🎯 方案概述

### 当前系统状态

你的飞书应用目前存储了以下敏感数据：

1. **用户授权信息**（`users` 表）
   - `access_token`：飞书访问令牌（明文）
   - `refresh_token`：刷新令牌（明文）

2. **邮箱账户信息**（`email_accounts` 表）
   - `password`：Exchange 邮箱密码（明文）

3. **业务数据**（`daily_reports` 表、`document_cache` 表）
   - `report_content`：生成的每日简报内容
   - `compressed_content`：缓存的飞书文档内容

4. **环境变量**（`.env` 文件）
   - `FEISHU_APP_SECRET`：飞书应用密钥
   - `SESSION_SECRET`：会话密钥
   - 其他敏感配置

### 安全风险

**场景1：数据库文件泄露**
- 如果数据库文件（`feishu_app.db`）被复制或备份泄露
- 攻击者可以直接读取所有敏感数据（token、密码、文档内容）

**场景2：环境变量泄露**
- 如果 `.env` 文件被误提交到代码仓库
- 或服务器文件被非授权访问
- 攻击者可以获得应用密钥，可能伪造请求

**场景3：容器重建导致数据丢失**
- 如果容器被删除重建，数据库文件在容器内会丢失
- 所有用户数据和配置都会丢失

### 解决方案

本方案通过三个方向提升安全性：

1. **Docker 卷挂载**：将数据库文件存储在宿主机，容器重建不丢失
2. **数据库字段加密**：敏感字段加密存储，即使文件泄露也无法直接读取
3. **环境变量加密**：`.env` 文件加密存储，需要密钥才能解密

---

## 📚 第一部分：Docker 数据持久化

### 1.1 什么是数据持久化？

**概念解释：**

想象一下，Docker 容器就像一个临时的工作房间：
- 你在房间里（容器内）创建的文件，如果房间被拆除（容器删除），文件就没了
- 数据持久化就是把重要文件放在房间外的保险柜（宿主机）里，房间重建后文件还在

**技术原理：**

```
┌─────────────────────────────────────┐
│  宿主机（服务器）                      │
│  ┌───────────────────────────────┐  │
│  │ /mnt/data/feishu_app.db       │  │  ← 数据库文件（持久存储）
│  └───────────────────────────────┘  │
│           ↕ 挂载（Volume）            │
│  ┌───────────────────────────────┐  │
│  │ Docker 容器                    │  │
│  │ /app/data/feishu_app.db       │  │  ← 容器内路径（映射到宿主机）
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

### 1.2 为什么需要数据持久化？

**当前问题：**

```bash
# 当前情况：数据库在容器内
容器内：/app/feishu_app.db

# 如果执行以下操作，数据会丢失：
docker rm -f feishu-app  # 删除容器
docker-compose down      # 停止并删除容器
docker-compose up --build  # 重建容器
```

**持久化后的好处：**

```bash
# 持久化后：数据库在宿主机
宿主机：/mnt/data/feishu_app.db
容器内：/app/data/feishu_app.db（映射到宿主机）

# 即使容器重建，数据依然存在
docker rm -f feishu-app
docker-compose up -d  # 数据还在！
```

### 1.3 实现方式

**方案：使用 Docker Volume 挂载**

在 `docker-compose.yml` 中添加数据卷挂载：

```yaml
volumes:
  # 现有挂载
  - .:/app                    # 项目目录
  - ./certs:/app/certs        # 证书目录
  
  # 新增：数据库持久化
  - ./data:/app/data          # 数据库目录（推荐）
  # 或
  - /mnt/data/feishu-app:/app/data  # 绝对路径（更安全）
```

**工作原理：**

1. 在宿主机创建数据目录（如 `./data` 或 `/mnt/data/feishu-app`）
2. 修改应用配置，将数据库路径改为 `/app/data/feishu_app.db`
3. Docker 将宿主机目录挂载到容器内
4. 数据库文件实际存储在宿主机，容器只是访问接口

### 1.4 安全考虑

**文件权限：**
- 确保数据目录权限正确（如 `chmod 700`）
- 只有应用用户能访问

**备份策略：**
- 定期备份数据目录
- 如果数据库已加密，备份文件也是加密的（更安全）

---

## 🔐 第二部分：数据库字段加密

### 2.1 什么是字段加密？

**概念解释：**

字段加密就像给保险箱里的重要文件上锁：
- 原始数据（明文）：`access_token = "abc123xyz"`
- 加密后（密文）：`access_token = "X9kL2mN8pQ5..."`（看起来像乱码）
- 只有用正确的密钥才能解密回原始数据

**加密流程：**

```
写入数据：
明文 → [加密算法 + 密钥] → 密文 → 存储到数据库

读取数据：
密文 → [解密算法 + 密钥] → 明文 → 返回给应用
```

### 2.2 为什么需要字段加密？

**当前风险：**

```sql
-- 如果数据库文件被复制，攻击者可以直接读取：
SELECT access_token, refresh_token FROM users;
-- 结果：abc123xyz, def456uvw（明文，直接可用）
```

**加密后的保护：**

```sql
-- 即使数据库文件被复制，攻击者看到的是：
SELECT access_token, refresh_token FROM users;
-- 结果：X9kL2mN8pQ5..., Y7jK3nM9pR6...（密文，无法直接使用）

-- 没有密钥，攻击者无法解密
```

### 2.3 加密方案选择

**我们选择：应用层字段加密（方案1A）**

**为什么选择这个方案？**

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **应用层字段加密** | ✅ 实现简单<br>✅ 不需要额外服务<br>✅ 可选择加密字段 | ⚠️ 需要密钥管理<br>⚠️ 查询性能略降 | **内网环境，快速提升安全性** |
| SQLite 加密扩展 | ✅ 数据库文件级加密 | ⚠️ 需要安装扩展<br>⚠️ 镜像变大 | 需要文件级保护 |
| 密钥管理服务 | ✅ 企业级安全 | ⚠️ 架构复杂<br>⚠️ 维护成本高 | 企业级部署 |

### 2.4 加密算法选择

**我们使用：AES-256-GCM**

**为什么选择 AES-256-GCM？**

- **AES-256**：目前最安全的对称加密算法之一
  - 256 位密钥，暴力破解几乎不可能
  - 被广泛使用和验证
  
- **GCM 模式**：Galois/Counter Mode
  - 提供加密 + 完整性验证（防止数据被篡改）
  - 性能好，适合生产环境

**Python 实现：**

```python
from cryptography.fernet import Fernet
# 或
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
```

### 2.5 需要加密的字段

根据数据敏感度，我们需要加密以下字段：

**极高敏感（必须加密）：**
- `users.access_token`
- `users.refresh_token`
- `email_accounts.password`

**高敏感（建议加密）：**
- `daily_reports.report_content`（简报内容）
- `document_cache.compressed_content`（文档内容）

**中敏感（可选加密）：**
- `users.folder_token`（文件夹 token）

### 2.6 实现原理

**加密工具类设计：**

```python
class EncryptionService:
    """加密服务类"""
    
    def __init__(self, key: str):
        # 从环境变量获取密钥
        self.key = self._derive_key(key)
    
    def encrypt(self, plaintext: str) -> str:
        """加密：明文 → 密文"""
        # 1. 使用 AES-256-GCM 加密
        # 2. 添加 IV（初始化向量）确保相同明文不同密文
        # 3. Base64 编码便于存储
        pass
    
    def decrypt(self, ciphertext: str) -> str:
        """解密：密文 → 明文"""
        # 1. Base64 解码
        # 2. 提取 IV
        # 3. 使用密钥解密
        pass
```

**数据库操作改造：**

```python
# 写入时加密
def save_user_token(user_id, access_token, refresh_token):
    encrypted_access = encryption_service.encrypt(access_token)
    encrypted_refresh = encryption_service.encrypt(refresh_token)
    # 存储加密后的数据
    db.save(user_id, encrypted_access, encrypted_refresh)

# 读取时解密
def get_user_token(user_id):
    encrypted_access, encrypted_refresh = db.get(user_id)
    access_token = encryption_service.decrypt(encrypted_access)
    refresh_token = encryption_service.decrypt(encrypted_refresh)
    return access_token, refresh_token
```

### 2.7 密钥管理

**密钥来源：环境变量 `ENCRYPTION_KEY`**

```bash
# 在宿主机设置
export ENCRYPTION_KEY="your-32-byte-key-here"

# 在 docker-compose.yml 中传递
environment:
  - ENCRYPTION_KEY=${ENCRYPTION_KEY}
```

**密钥生成：**

```python
# 生成安全的随机密钥（32 字节 = 256 位）
from cryptography.fernet import Fernet
key = Fernet.generate_key()  # 生成并保存
```

**密钥安全：**
- ✅ 密钥不在代码仓库中
- ✅ 通过环境变量传递
- ⚠️ 需要保护环境变量不被泄露（见第三部分）

### 2.8 数据迁移

**现有数据怎么办？**

如果数据库中已有明文数据，需要迁移：

1. **读取现有明文数据**
2. **使用新密钥加密**
3. **写回数据库**

```python
# 迁移脚本示例
async def migrate_existing_data():
    users = await db.get_all_users()
    for user in users:
        # 如果已经是密文，跳过
        if is_encrypted(user.access_token):
            continue
        # 加密并更新
        encrypted_token = encryption_service.encrypt(user.access_token)
        await db.update_user_token(user.user_id, encrypted_token)
```

---

## 🔒 第三部分：环境变量加密

### 3.1 什么是环境变量加密？

**概念解释：**

环境变量加密就像给配置文件上锁：
- 原始 `.env` 文件：`FEISHU_APP_SECRET=abc123`（明文）
- 加密后的 `.env.encrypted` 文件：`X9kL2mN8pQ5...`（密文）
- 应用启动时用密钥解密，加载到内存中使用

**加密流程：**

```
开发/部署时：
.env（明文） → [加密工具 + 密钥] → .env.encrypted（密文）

应用启动时：
.env.encrypted（密文） → [解密工具 + 密钥] → 加载到环境变量
```

### 3.2 为什么需要环境变量加密？

**当前风险：**

```bash
# .env 文件内容（明文）
FEISHU_APP_SECRET=cli_xxxxxxxxxxxxx
SESSION_SECRET=your_secret_key_here

# 风险场景：
# 1. 误提交到 Git 仓库（git add .env）
# 2. 服务器文件被非授权访问
# 3. 备份文件泄露
```

**加密后的保护：**

```bash
# .env.encrypted 文件内容（密文）
X9kL2mN8pQ5Y7jK3nM9pR6...

# 即使文件泄露，没有密钥无法解密
```

### 3.3 实现方案

**方案：加密的 .env 文件（方案2A）**

**工作流程：**

1. **开发/部署阶段**：
   ```bash
   # 创建明文 .env 文件（不提交到 Git）
   FEISHU_APP_SECRET=abc123
   SESSION_SECRET=xyz789
   
   # 使用工具加密
   python encrypt_env.py .env .env.encrypted
   # 生成 .env.encrypted（可以提交到 Git）
   ```

2. **应用启动阶段**：
   ```python
   # app.py 启动时
   if os.path.exists('.env.encrypted'):
       # 从环境变量获取解密密钥
       decryption_key = os.getenv('ENCRYPTION_KEY')
       # 解密 .env.encrypted
       decrypted_env = decrypt_env_file('.env.encrypted', decryption_key)
       # 加载到环境变量
       load_env_from_string(decrypted_env)
   else:
       # 兼容：如果没有加密文件，使用普通 .env
       load_dotenv('.env')
   ```

### 3.4 加密工具设计

**加密脚本：`scripts/encrypt_env.py`**

```python
"""
环境变量加密工具

用法：
    python scripts/encrypt_env.py .env .env.encrypted
"""
import sys
from cryptography.fernet import Fernet

def encrypt_env_file(input_file, output_file, key):
    """加密 .env 文件"""
    # 1. 读取明文 .env
    # 2. 使用密钥加密
    # 3. 写入 .env.encrypted
    pass
```

**解密功能：集成到应用启动**

```python
# utils/env_loader.py
def load_encrypted_env(encrypted_file, decryption_key):
    """加载加密的环境变量文件"""
    # 1. 读取 .env.encrypted
    # 2. 使用密钥解密
    # 3. 解析为环境变量字典
    # 4. 设置到 os.environ
    pass
```

### 3.5 密钥管理

**密钥来源：环境变量 `ENCRYPTION_KEY`**

```bash
# 在宿主机设置（与数据库加密使用同一个密钥）
export ENCRYPTION_KEY="your-32-byte-key-here"
```

**为什么使用同一个密钥？**

- ✅ 简化管理：只需要管理一个密钥
- ✅ 统一安全：所有加密使用相同标准
- ⚠️ 风险：如果密钥泄露，所有加密数据都可解密（但这是可接受的风险，因为密钥本身需要严格保护）

### 3.6 开发与生产环境

**开发环境（本地）：**

```bash
# 使用明文 .env（方便开发）
.env  # 不提交到 Git（已在 .gitignore）

# 或使用加密文件（更安全）
.env.encrypted  # 可以提交到 Git
```

**生产环境（服务器）：**

```bash
# 只使用加密文件
.env.encrypted  # 提交到代码仓库

# 启动时通过环境变量提供密钥
export ENCRYPTION_KEY="..."
docker-compose up -d
```

### 3.7 安全考虑

**密钥保护：**
- 密钥通过环境变量传递，不在代码中
- 需要保护环境变量不被泄露（见前面的风险分析）

**文件权限：**
- `.env.encrypted` 可以提交到 Git（因为是加密的）
- `.env` 不能提交到 Git（明文）
- 确保 `.gitignore` 包含 `.env`

---

## 🔄 第四部分：整体架构

### 4.1 数据流图

```
┌─────────────────────────────────────────────────────────┐
│  宿主机（服务器）                                        │
│                                                         │
│  ┌─────────────────────────────────────────────────┐  │
│  │ 环境变量：ENCRYPTION_KEY                        │  │
│  └─────────────────────────────────────────────────┘  │
│                        ↕                                │
│  ┌─────────────────────────────────────────────────┐  │
│  │ Docker 容器                                      │  │
│  │                                                  │  │
│  │  1. 启动时：                                      │  │
│  │     ┌──────────────────────┐                    │  │
│  │     │ 读取 .env.encrypted  │                    │  │
│  │     │ 使用 ENCRYPTION_KEY  │                    │  │
│  │     │ 解密 → 加载环境变量   │                    │  │
│  │     └──────────────────────┘                    │  │
│  │                                                  │  │
│  │  2. 运行时：                                      │  │
│  │     ┌──────────────────────┐                    │  │
│  │     │ 写入数据库           │                    │  │
│  │     │ 敏感字段加密         │                    │  │
│  │     │ 使用 ENCRYPTION_KEY  │                    │  │
│  │     └──────────────────────┘                    │  │
│  │              ↕                                   │  │
│  │     ┌──────────────────────┐                    │  │
│  │     │ /app/data/            │                    │  │
│  │     │ feishu_app.db         │                    │  │
│  │     │ (加密的敏感字段)      │                    │  │
│  │     └──────────────────────┘                    │  │
│  └─────────────────────────────────────────────────┘  │
│                        ↕ Volume 挂载                    │
│  ┌─────────────────────────────────────────────────┐  │
│  │ /mnt/data/feishu-app/feishu_app.db             │  │
│  │ (持久化存储，加密的敏感字段)                     │  │
│  └─────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 4.2 安全层次

**多层防护：**

```
第1层：环境变量加密
  ↓ 保护：.env 文件泄露
  ↓ 即使文件被复制，没有密钥无法解密

第2层：数据库字段加密
  ↓ 保护：数据库文件泄露
  ↓ 即使数据库被复制，敏感字段是加密的

第3层：Docker 卷挂载
  ↓ 保护：数据持久化
  ↓ 容器重建不丢失数据，便于备份

第4层：密钥管理（环境变量）
  ↓ 保护：加密密钥
  ↓ 密钥不在代码中，通过环境变量传递
```

### 4.3 密钥管理策略

**单一密钥方案：**

- 使用同一个 `ENCRYPTION_KEY` 用于：
  - 环境变量解密
  - 数据库字段加密/解密

**优点：**
- ✅ 管理简单
- ✅ 统一安全标准

**缺点：**
- ⚠️ 密钥泄露影响所有加密数据
- ⚠️ 但这是可接受的风险（密钥本身需要严格保护）

**密钥生成：**

```python
# 生成 32 字节（256 位）密钥
from cryptography.fernet import Fernet
key = Fernet.generate_key()
print(key.decode())  # 保存这个值
```

**密钥存储：**
- 在宿主机设置环境变量
- 通过 Docker 传递给容器
- 不在代码仓库中

---

## 📝 第五部分：实施步骤

### 5.1 实施顺序

**阶段1：Docker 卷挂载（必须，最简单）**
1. 创建数据目录
2. 修改 docker-compose.yml
3. 修改数据库路径配置
4. 测试数据持久化

**阶段2：数据库字段加密（核心安全）**
1. 创建加密服务类
2. 修改数据库操作代码
3. 编写数据迁移脚本
4. 测试加密/解密功能

**阶段3：环境变量加密（增强安全）**
1. 创建加密工具脚本
2. 加密现有 .env 文件
3. 修改应用启动代码
4. 测试加密文件加载

### 5.2 风险评估

**实施风险：**

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| 密钥丢失 | 无法解密数据 | 备份密钥到安全位置 |
| 加密算法错误 | 数据损坏 | 充分测试，保留备份 |
| 性能影响 | 响应变慢 | 使用高效算法（AES-GCM） |
| 数据迁移失败 | 数据丢失 | 先备份，再迁移 |

**回滚方案：**

- 保留原始数据库备份
- 保留原始 .env 文件
- 如果出现问题，可以回滚到未加密版本

### 5.3 测试策略

**单元测试：**
- 加密/解密功能测试
- 数据库操作测试
- 环境变量加载测试

**集成测试：**
- 完整数据流测试（写入 → 加密 → 存储 → 读取 → 解密）
- Docker 容器测试
- 数据迁移测试

**安全测试：**
- 验证加密后的数据无法直接读取
- 验证密钥错误时无法解密
- 验证文件权限正确

---

## 🎓 第六部分：概念解释（初学者友好）

### 6.1 加密基础概念

**什么是加密？**

加密就像给信息上锁：
- **明文**：原始信息，可以直接读懂
  - 例如：`password = "123456"`
  
- **密文**：加密后的信息，看起来像乱码
  - 例如：`password = "X9kL2mN8pQ5Y7jK3nM9pR6..."`

- **密钥**：用来加密和解密的"钥匙"
  - 没有密钥，无法从密文恢复明文

**加密算法：**

- **对称加密**：加密和解密使用同一个密钥
  - 例如：AES-256（我们使用的）
  - 优点：速度快，适合大量数据
  - 缺点：密钥需要安全传递

- **非对称加密**：加密和解密使用不同密钥（公钥/私钥）
  - 例如：RSA
  - 优点：密钥传递更安全
  - 缺点：速度慢，不适合大量数据

### 6.2 Docker Volume 概念

**什么是 Volume？**

Volume 是 Docker 的数据持久化机制：

```
容器内文件系统（临时）：
/app/feishu_app.db  ← 容器删除后消失

Volume 挂载（持久）：
宿主机：/mnt/data/feishu_app.db
   ↕ 挂载
容器内：/app/data/feishu_app.db  ← 实际存储在宿主机
```

**为什么需要 Volume？**

- 容器是临时的，删除后数据丢失
- Volume 将数据存储在宿主机，容器重建后数据还在

### 6.3 环境变量概念

**什么是环境变量？**

环境变量是操作系统提供的配置机制：

```bash
# 设置环境变量
export ENCRYPTION_KEY="abc123"

# 程序可以读取
python
>>> import os
>>> os.getenv("ENCRYPTION_KEY")
'abc123'
```

**为什么用环境变量存储密钥？**

- ✅ 不在代码中硬编码（安全）
- ✅ 不同环境可以用不同配置
- ✅ 不需要修改代码就能改变配置

### 6.4 安全原则

**最小权限原则：**
- 只给必要的权限
- 例如：数据库文件只有应用用户能访问

**纵深防御：**
- 多层安全措施
- 即使一层被突破，还有其他层保护

**密钥分离：**
- 密钥和数据分离存储
- 即使数据泄露，没有密钥也无法解密

---

## 📊 第七部分：性能影响

### 7.1 加密性能

**AES-256-GCM 性能：**

- **加密速度**：现代 CPU 可以每秒加密数 GB 数据
- **对应用影响**：几乎可以忽略（毫秒级）

**实际测试（参考）：**
```
加密 1KB 数据：< 1ms
加密 1MB 数据：< 10ms
```

### 7.2 数据库性能

**字段加密对查询的影响：**

- **写入**：需要加密，增加 ~1-2ms
- **读取**：需要解密，增加 ~1-2ms
- **查询**：无法对加密字段直接查询（需要先解密）

**优化建议：**
- 只加密敏感字段，不加密索引字段
- 使用高效的加密算法（AES-GCM）
- 缓存解密后的常用数据（如果安全允许）

### 7.3 启动性能

**环境变量解密：**

- 解密时间：< 10ms（文件通常很小）
- 对启动时间影响：可忽略

---

## ✅ 第八部分：检查清单

### 实施前检查

- [ ] 已备份原始数据库
- [ ] 已备份原始 .env 文件
- [ ] 已生成并安全保存 `ENCRYPTION_KEY`
- [ ] 已测试密钥可以正常使用

### 实施后检查

- [ ] Docker 卷挂载正常工作
- [ ] 数据库文件在宿主机正确存储
- [ ] 容器重建后数据不丢失
- [ ] 数据库字段加密/解密正常
- [ ] 可以正常读取加密的数据
- [ ] 环境变量加密文件可以正常加载
- [ ] 应用可以正常启动和运行

### 安全检查

- [ ] 数据库文件权限正确（600 或 700）
- [ ] 数据目录权限正确
- [ ] `.env` 文件不在 Git 仓库中
- [ ] `.env.encrypted` 可以提交到 Git
- [ ] `ENCRYPTION_KEY` 不在代码中
- [ ] 密钥已备份到安全位置

---

## 📚 第九部分：参考资料

### 加密相关

- **AES 加密算法**：https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
- **Python cryptography 库**：https://cryptography.io/
- **Fernet 对称加密**：https://cryptography.io/en/latest/fernet/

### Docker 相关

- **Docker Volume 文档**：https://docs.docker.com/storage/volumes/
- **Docker Compose volumes**：https://docs.docker.com/compose/compose-file/compose-file-v3/#volumes

### 安全最佳实践

- **OWASP 安全指南**：https://owasp.org/
- **密钥管理最佳实践**：https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html

---

## 🎯 总结

### 方案价值

1. **数据持久化**：确保数据不丢失
2. **数据加密**：即使泄露也无法直接使用
3. **配置加密**：保护敏感配置信息

### 安全提升

- **数据库泄露风险**：从"直接可读"降低到"需要密钥解密"
- **配置泄露风险**：从"直接可用"降低到"需要密钥解密"
- **数据丢失风险**：从"容器重建丢失"降低到"持久化存储"

### 实施建议

1. **按阶段实施**：先做简单的（卷挂载），再做复杂的（加密）
2. **充分测试**：每个阶段都要测试，确保功能正常
3. **保留备份**：实施前备份所有数据
4. **文档记录**：记录密钥位置、备份位置等重要信息

---

**下一步**：阅读完本文档后，如果理解并同意方案，我们可以开始实施。

**如有疑问**：请随时提问，我会详细解释。
